---
layout: post
title:  "[技术]当我的程序 coredump 的时候我该做什么？"
date:   2016-06-01 01:55:00
categories: 技术
tags: tech c/c++ debug
permalink: /:year/:month/:title
---

> what should I do when my program got a coredump?

coredump 对程序员来说是一件很操蛋的事情，然而常在河边走，哪能不湿鞋；面对让人心烦的 coredump ，这里记录着一份流传已久的老司机清单，新手们可以按图索骥。

## coredump? WTF?
如果你还不知道什么是 coredump ，或许你该补补课了, RTFM！以下摘自中文维基：

> 核心文件（core file），也称核心转储（core dump），在汉语中有时戏称为吐核，是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件。这种信息往往用于调试。

然后我们进入正题。

## First Step: 进入程序运行的目录使用 gdb 调试
首先说明一件事情，不喜欢频繁 cd 切换目录的同学这里会被坑。因为执行类似：

~~~~
gdb directory/program_name coredump_file
~~~~

会让你没有办法获得完整的 core dump 信息，别问我为什么，在 gdb 版本 6.6 的时候就是这样的，也许更新版本的 gdb 是没有问题的，反正我还没领会到其中的真谛。

所以使用 gdb 调试的时候注意这个小问题，一定 cd 到程序目录下。然后我们执行一下：

~~~~
gdb program_name coredump_file
~~~~

会看到类似下面的信息（摘自网络）：

~~~~
Core was generated by './core_demo'.
Program terminated with signal 11, Segmentation fault.
#0  0x080483cd in func (p=0x0) at core_demo.c:5
5       int y = *p;
(gdb)  where
#0  0x080483cd in func (p=0x0) at core_demo.c:5
#1  0x080483ef in main () at core_demo.c:12
(gdb) info frame
Stack level 0, frame at 0xffd590a4:
 eip = 0x80483cd in func (core_demo.c:5); saved eip 0x80483ef
 called by frame at 0xffd590c0
 source language c.
 Arglist at 0xffd5909c, args: p=0x0
 Locals at 0xffd5909c, Previous frame's sp is 0xffd590a4
 Saved registers:
  ebp at 0xffd5909c, eip at 0xffd590a0
~~~~

其中

~~~~
(gdb) where
~~~~

或者
~~~~
(gdb) bt
~~~~
可以看到具体 coredump 的位置，直接定位到问题代码。一般到这里我们就能定位到问题了。
~~~~
#0  0x080483cd in func (p=0x0) at core_demo.c:5
#1  0x080483ef in main () at core_demo.c:12
~~~~
比如上面这里，定位到问题出现在 func 函数，可以直接看下文件 core_demo.c 的第五行。

当然 gdb 还有很多简单而强大的指令，比如：
~~~~
(gdb) info frame
~~~~
它可以让你看到栈帧的地址，存放的参数等信息。
~~~~
Stack level 0, frame at 0xffd590a4:
 eip = 0x80483cd in func (core_demo.c:5); saved eip 0x80483ef
 called by frame at 0xffd590c0
 source language c.
 Arglist at 0xffd5909c, args: p=0x0
 Locals at 0xffd5909c, Previous frame's sp is 0xffd590a4
 Saved registers:
  ebp at 0xffd5909c, eip at 0xffd590a0
~~~~
让我们来一一分析一下通过 info frame 指令显示出的内容吧。
~~~~
Stack level 0, frame at 0xffd590a4:
~~~~
表示当前是 backtrace 中第 0 个栈帧，以及栈帧的地址。
~~~~
 eip = 0x80483cd in func (core_demo.c:5); saved eip 0x80483ef
~~~~
eip 是下次 CPU 要执行的指令地址，这里打印出 eip 下次CPU 要执行的指令地址 和 执行完成后返回的 eip 值，确保被调完成后能返回到调用指令的地方。
~~~~
 called by frame at 0xffd590c0
~~~~
这里表示被上一个栈帧调用的内存位置。
~~~~
source language c.
~~~~
这里显示的程序是 C 语言编写的。

~~~~
Arglist at 0xffd5909c, args: p=0x0
~~~~
函数参数列表的内存地址和参数内容（这里是一个空指针，笑）。

~~~~
Locals at 0xffd5909c, Previous frame's sp is 0xffd590a4
~~~~
本地变量的地址。

~~~~
Saved registers:
 ebp at 0xffd5909c, eip at 0xffd590a0
~~~~
寄存器存储的内容。

这里解释下，这里打印出的 eip 就是下次 CPU 要执行的指令地址， 而 ebp 是栈底的指针。
需要再提一句的是， ebp 的值通常是在进入函数前，通过栈顶指针 esp 赋值给 ebp 的，而通过 ebp 来获取栈间的各种数据。获取这些信息，我们就能掌握到当前程序运行的具体状态了。

下面是详细的文档：

> info frame

> info f

* This command prints a verbose description of the selected stack frame, including:
* the address of the frame
* the address of the next frame down (called by this frame)
* the address of the next frame up (caller of this frame)
* the language in which the source code corresponding to this frame is written
* the address of the frame's arguments
* the address of the frame's local variables
* the program counter saved in it (the address of execution in the caller frame)
* which registers were saved in the frame
* The verbose description is useful when something has gone wrong that has made the stack format fail to fit the usual conventions. 

> info frame addr
> info f addr

* Print a verbose description of the frame at address addr, without selecting that frame. The selected frame remains unchanged by this command. This requires the same kind of address (more than one for some architectures) that you specify in the frame command. See Selecting a Frame.

## Second Step: 没有发现 core 文件？
确定 core 文件大小是否受到限制。

使用
~~~~
ulimit -a 
~~~~
查看 ulimit 配置，ulimit -c 可以查看 core 文件大小的设置，使用

~~~~
ulimit -c unlimited -S
~~~~
修改系统资源限制为无限制，但是注意这只会在当前的会话下有效。

## Third Step: 堆栈信息不够详细？
很有可能在编译完成后执行了 strip 命令。通过 man strip: 

~~~~
strip - Discard symbols from object files.
~~~~

google 一下: 

~~~~
strip 命令减少 XCOFF 对象文件的大小。
strip 命令从 XCOFF 对象文件中有选择地除去行号信息、重定位信息、调试段、typchk 段、注释段、文件头以及所有或部分符号表。 
一旦您使用该命令，则很难调试文件的符号；因此，通常应该只在已经调试和测试过的生成模块上使用 strip 命令。
使用 strip 命令减少对象文件所需的存储量开销。
~~~~

所以，可以通过去掉 makefile 中的 strip 命令来保留更多的 debug 信息，更方便的定位问题。

## Fourth Step: 看不懂的coredump？
经过上面三步还是不知道问题在哪里？你运气不错，可以去试试买彩票（大雾），这时也许应该低吼一声，“重编大发好”。从头编译整个项目或许是最不需要动脑的解决方案，也许等明天早上就编译好了，问题就解决了呢:)。

开个玩笑，哈哈。这篇废话连篇的文章只是教你如何简单快速的定位问题，并没有进阶的内容，如果以上方法没有版本帮你解决到问题，可以通过文档找到更多的内容:)。

[GNU GDB Document](http://www.gnu.org/software/gdb/documentation/)

[GNU Make](http://www.gnu.org/software/make/manual/make.html)

